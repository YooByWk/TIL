# 2023_08_09

## 스택 top! push! pop! 
  -논..리;적;인./...자료\구/조.. "논리적임" <-> 리스트는 물리적임
- 물건 쌓은 것 처럼 
- 스택에 저장된 자료는 선형 구조를 가짐
  - 선형 구조 : 자료간 관계가 1:1
  - 비선형 구조 : 자료간 관계가 1:N ej.트리
- 자료를 삽입하거나 자료를 꺼낼 수 있음 
-  LIFO / 마지막 삽입 자료를 가장 먼저 꺼낸다. |후입선출 last in first out| 

자료구조 : 선형으로 저장할 저장소 
마지막 원소의 위치를 top이라고 부른다. or sp

- 연산
  -  삽입 : 저장소에 자료 저장 주로 push라고 부름
  -  삭제 : 저장소에서 자료를 꺼냄, 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 pop이라고 부름
  -  스택이 공백인지 아닌지 확인하는 연산 isEmpty
  -  스택의 top에 있는 item(원소)을 반환하는 연산 peek

스택의 push...
- append 통해 리스트의 마지막에 데이터 삽입...
```py
def push(item):
    s.append(item)
```
```py 
#참고
def push(item, size):
    global top 
    top += 1 
    if top == size:
        print('overflow!')
    else:
        stack[top] = item
size = 10
stack = [0] * size
top = -1

push(10,size)
top += 1  # push(20)을 하겠다는 뜻??
stack[top] = 20 #
```
```py 
def pop():
    if len(s) == 0:
        #underflow
        return 
    else : s.pop()
```
```py
def pop():
    global top 
    if top == -1 : 
        print('underflow')
        return 0
    else : 
        top -= 1
        return stack[top+1]

print(pop())

if top > -1 :
    top -= 1 
    print(stack[top+1])
```
### 스택 고려사항 
1차원 배열을 사용하여 구현할 경우
- 장점 : 구현이 용이하다
- 단점 : 스택의 크기 변경이 어렵다

저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다. 동적 연결리스트를 이용하여 구현하는 방법을 의미한다. 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 지닌다. 
*스택의 동적 구현은 생략함.*

### 응용
#### 괄호 문제... 
괄호의 종류 : 대괄호[] 중괄호 {} 소괄호 ()
1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다. 
3. 괄호 사이에는 포함 관계만 존재한다.

괄호 조사 알고리즘 개요 
- 괄호 조사하면서 왼쪽 괄호를 만나면 스택에 삽입
- 오른쪽 괄호를 만나면 스택에서 top 괄호 삭제 후 오른쪽 괄호와 짝이 맞는지
- 스택이 비어있으면 조건 1 or 조건 2 위배 짝 안맞으면 조건 3 위배
- 마지막까지 조사한 후에도 남아있으면  조건 1 위배

### functon call 

함수 호출과 복귀에 따른 전체 프로그램의 진행 순서는... 스택을..
이용중인 것 같아요 
저는그만정신을잃고말았습니다. 두번 보기 ...

-프로그램에서의 함수 호출과 복귀에 따른 수행 순서 관리
<p>

[스택관련 무언가1](https://ko.javascript.info/recursion)
<p>

[스택관련 무언가2](https://bentist.tistory.com/57) 

  - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로 후입선출 구조의 스택을 이용하여 수행순서 관리
  - 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수 및 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입한다.
  - 함수의 실행이 끝나면 시스템 스택의 top원소(스택 프레임)를 삭제하며 프레임에 저장되어있던 복귀 주소를 확인하고 복귀
  - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 **시스템 스택은 공백 스택이 된다.**
  
### 재귀호출
자기 자신을 호출하여 순환 수행 되는 것
프로그램 크기 줄이기 가능하기도 함.


#### 피보나치 수열 
0 1 1 2 3 5 8 13 ... 어...
피보나치 수열의 i번째 값을 계산하는 함수 F 
F(0) = 0, F(1) = 1
F(i) = F(i-1) + F(i-2) for i >= 2

```py
def fibo(n) :
    if N <2 :
        return n
    else : 
        return fibo(n-1) + fibo(n-2) #엥 간단하네?
```
피보나치 call tree : 아무튼 복잡함

#### Memoization 
 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술. 동적 계획법의 핵심이 되는 기술

- memorandum lat.

앞의 예에서 fibo(n) 값 계산하자마자 저장하면(memorare) > 실행시간 감소 
```py
def fibo1(n):
    global memo
    if >= 2 and memo[0] == 0 : 
        memo[n] = (fibo1(n-1) + fibo1(n-2))
    return memo[n]
memo = [0] * (n + 1)
memo[0] = 0 
memo[1] = 1

완성!

``````




[이전](../../2023_08_AGO/2023_08_08/README.md)

[다음](../../2023_08_AGO/2023_08_10/README.md)