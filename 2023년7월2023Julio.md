# 2023. 07 
## Julio

>> ### 2023/07/12 
- SSAFY 확정반 결정일!!
- git을 만들다.
- [git 사용법을 배웠다](git.md)
- [마크다운](mkdw.md) 사용법을 ~~조금~~ 배웠다. + Commit!
- ChatGPT와 API를 이용한 간단한 놀이
- Visual Studio Code를 설치!
- CLI vs GUI + 약간의 CLI 명령어
---
> >### 2023/07/13
- [git](git.md)의 push / pull / clone 
- TIL의 시작!
- [git](git.md)의  gitignore을 조금 봤다
- VS Code에서 [Python](python.md)을 사용해봤다.
 ``` Python
    print(1)
 ```
- 컴퓨터 프로그래밍 언어의 간략한 역사<br>
      기계어... C언어...
~~ㄷㄷㄷㄷ~~
```cpp
    #include <stdio.h>
    int main()
    {
        printf("Hello World);
    }```
```
- 오늘시작한 따끈한[코?딩](my_code_julio.md)
- for문이 미워요 틀리면서 이해하는 파이썬 첫걸음.
- ---
>>### 2023/07/14
```python
import random
menu = ['지코바', '설렁탕', '콩국수', '불백']
for i in range(0,5):
    selec = random.choice(menu)
    print(selec)
```
>'함수' >> 값 하나만 준다!
- 함수 불러오기.
- **for** 복습
- 리스트['a', 1, 'b', 2], 딕셔너리 {a:b, c:d}
- 내장함수  vs 외장함수 : 한번 봐야겠지?
```python
 #리스트 >
A_list.index('알고싶은 위치')

#딕셔너리 친구... 나중에 만나자!
dust = {'영등포구':58, '강남구':34, '서대문구':40, '마포구':27, '노원':80}
print(dust['영등포구']) # 58만 print 함
```
#### Sort()의 출력값은 None!
#### 2차원 배열 ? a = [[1, 2, 3], [2, 3, 4],[1, 2, 3]] 요런 느낌?
#### ~~리스트에 리스트 append해버리는 느낌?~~
---
>> ### 2023_07_16
문제풀이 트라이!
<p>결국...해냈...다...

---
>> ### 2023_07_17
---
- Numeric Type
  - int, float, complex
<br>
- Sequence Types
  - list, tuple, range

- Text Sequence Type 
    - str
-  Set Types
   -  set 
- Mapping Types
  -  dict<br>
- Etc.
  <p>None, Boolean, Funcion<p>
---
표현식 (순차적으로 평가) > 동작
``` python
degrees = 36.5 #할당문 예시
#변수 에 36.5 할당
number = 10
double = 2 * number
print(double) # 20

number =5 
print(double) # 10

```
> Style Guide
코드의 일관성과 가독성을 향상시키기 위한 규칙과 권장 사항들의 모음

[peps.python.org/pep-0008]([peps.python.org/pep-0008])
<p>

- 변수명은 무엇을 위한 변수인지 확인 위한 직관적 작명

- 공백(spaces) 4칸을 사용하여 코드블록 들여쓰기

- 한 줄의 길이는 79자로 제한, 길어지면 줄 바꿈
문자와 밑줄((Snake_case))을 사용하여 함수, 변수, 속성의 이름 작성<p>
- 함수 정의나 클래스 정의 등의 블록 사이에는 빈 줄 추가<p>

```python
a = 1 
b = 2
c = a + b

num1 = 1
num2 = 2
sum_result = num1 + num 2

num = [1, 2, 3, 4, 5] #님아 이건 리스트잖아요
# nums or num_list 요렇게 하는게 더 좋겟 죠?
for number in numbers:
    #요론 예시 때문에
student_grades = [ 24, 74, 6]
is_asd -> True / False  의 느낌

#시간 예시 (상수)
secs = 60    #|
minute = 60  #| 셋다 고정값이니까
hours = 24   #| 대문자로 합시다
#>>>
SECONDS_PER_MINUTE = 60 # 이런 느낌

def sample():
    adadadadadad #정말 깔끔하게 말이죠
    sdfaasdfasdfsdaf

def asdsadasd():
    asdafasf    #우리 좀 깔끔하게 살아봐요
    sadfasdfkj

RESULT=2+3*(4-5)/2 #제발 이러지 마세요
result = 2 + 3 * (4 - 5) / 2  #편안

def sample():
    """
    주로 설명용
    ej. 이 함수는 아무튼 함수입니다. 
    얘도 주석이네 헉 or Ctrl + / <- 일반적
    주석 : 설명 / 임시 비활성 
    이해 / 문서화
    의도 동작 설명
    """ 

```
jupyter notebook 사용 연습<p>
설치 > notion/index 참조<P>
키 > notion/PJT
실행해보면서 문서 만들기 가능<p>
python tutor와 jupyter nothebook은 "학습도구"


>> ### 2023.07.17~18 

> int - 정수 자료형<p>

2진수   :binary      : 0b<p>
8진수   :octal       : 0o<p>
16진수  :hexadecimal : 0x <p>

> float - 실수 자료형

float 는 실수에 대한 근삿값
 - 유한 정밀도
   - 메모리 한정 -> 한 숫자 저장 제한 = 가장 가까운 값!
  ```python
  # 0.6666666666666666
print(2 / 3)
  # 1.6666666666666667
print(5 / 3)
```
지수 표현 방식 
```python
# 314 ∗ 0.01
number = 314e-2

# float
print(type(number))

# 3.14
print(number)
``````
        <class 'float'>
        3.14
```python        
# 실행 해보기 2
a = 3.2 - 3.1 
b = 1.2 - 1.1 

print(a)
print(b)

print(abs(a - b) <= 1e-10) 
 
import math
print(math.isclose(a, b))

0.10000000000000009
0.09999999999999987
True
True
```
음! 봐도 모르겠군! 
대충 두개가 비슷한듯.

> Sequence Types
1. 순서(Sequence) 
   - 값들이 순서대로 저장됨 (정렬 X)
2. 인덱싱 (Indexing)
    - 각 값에 고유한 인덱스, 인덱스를 사용, 특정위치 값 선택, 수정 가능함
3. 슬라이싱 (Slicing)
    - 인덱스 범위 조절하여 부분값 추출 가능
4. 길이 (Length)
    - len()함수로 저장된 값의 개수(길이) 구할 수 있음
5. 반복 (Iteration)
    - 반복문을 사용, 저장된 값들을 반복적으로 처리할 수 있음

> str 문자열
 
문자들의 순서가 있는 변경 불가능한 시퀀스 자료형

' ' 혹은 " "로 표현 <P>
- 중첩 따옴표
```python
# 문자열 안에 "큰따옴표"를 사용하려면 작은 따옴표로 묶는다.
print('문자열 안에 "큰따옴표"를 사용하려면 작은 따옴표로 묶는다.')
```
> Escape sequence
>
backslash + 특정 문자 = 특수 기능
일반적 파이썬 문법 잠시 탈출

| 예약 문자 | 내용(의미) | |:------------------: |:------------------: | 

| \n | 줄 바꿈 | <p>
| \t | 탭 | <p>
| \ | 백슬래시 |<p> 
| \’ | 작은 따옴표 |<p> 
| " | 큰 따옴표 |<p>
- [ ] 여기 수정하기... 표 양식으로 
> String Interpolation
> 

  f/F 접두어 + {expression}
  ej.
  ```python
  bug = 'roaches'
  counts = 13
  area = 'living room' #끔찍
  #Debugging roaches 13 living room -출력
  print(f'Debugging {bugs} {counts} {area}')
  #편안합니다. 아래 두 개에 비하면
  print('Debugging {} {} {}'.format(bugs, counts, area)) #예전에 쓰던것 1 // 보는법은 알아두기

  print('Debugging %s %d %s' % (bugs, counts, area)) #고대인의 방법 // 보는법은 알아두기
  ```
  ㅖ. 

```python
my str_'hello'
#인덱싱
print(my_str[1]) # e 
#슬라이싱
print(my_str[2:4]) # ll
#길이
print(len(my_str)) # 5 
# 이런 모양 이런 느낌
my_str[0:0:0] #[시작,끝,간격]
my_str[::-1] #반대로나옴
```
근데 리스트는 가변
> ### tuple  튜플 얘는 불변...
- 소괄호로 (표 기)
- 어떤 자료형이든지 OK 심지어
- 인덱싱, 슬라이싱 OK 단 변경 X 
- 안전하게 여러 값 전달! 그룹화! 다중 할당!
  
>Non-sequence Types

> dict 딕셔너리

     key values 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형
> 
> key는 변경 불가한 자료형
 - key(str, int, float, tuple, range...)
 - value는 모든 자료형
 - {} 중괄호로 ! key : value 모양
  ```python
  my_dict_1 = {'key' : 'value'}
  print(my_dict['key']) #'value'
  my_dict_1['key'] = 'valllllue'
  for key, value in information.items():
      print(key, value)
  #키-밸류 다 불러오기
  ```
> set 세트 (집합)

- 중괄호
- set{1, 2, 3}
```python
  # 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}
#| 는 버티컬바 쉬프트 + \
# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

# 교집합
print(my_set_1 & my_set_2)  # {3}
```
>OTHER TYPES 

- None : 값이 없어...

-Boolean  True / False

> Collection
> 
|컬렉션 |변경 가능 여부|나열여부||
|:---:|:---:|:---:|:---:|
| str | X | O | 시퀀스 |
| list | O | O | 시퀀스 |
| tuple | X | O | 시퀀스 |
| set | O | X | 비시퀀스 | 
| dict | O | X | 비시퀀스 |
변경가능에서  dict의 key는 예외.

### 2023.07.18

입학식

 ```python
 #진법 변경  / bin...
 print(bin(12)) # 2진법 #0b1100
print(oct(12)) # 8진 0o14
print(hex(12)) # 16진 0xc
# 실수 연산 해결책 -메모리 한계로 대충 숫자가...
a = 3.2 - 3.1 # 0.10000000000000009 쯤
b = 1.2 - 1.1  # 0.0999999999999987 쯤
# 1. 임의의 작은 수 활용
print(abs(a - b) <= 1e-10>) # True
# 2. math 모듈 활용 
import math
print(math.isclose(a, b)) # True

 ``` 
 f-string 추가

 ``` python
 greeting = 'hi'
print(f'{greeting:^10}' )#     hi     양쪽에 5,4칸씩 공백 추정
print(f'{greeting:<10}') # hi         오른쪽에 9칸 공백 추정
print(f'{greeting:>10}') #         hi 왼쪽에 9칸 공백 추정 

print(f'{3.141592:.4f}') # 소수 4번째까지만 
 ```

편법같은 느낌으로 
set 이용해서 리스트 중복요소 제거 가능.

얕은 복사 조오오금
``` python
list_1 = [1, 2, 3]
list_2 = list_1
list_1[0] = 100
print(list_1)
print(list_2)

#list_2에 list_1을 할당 (값이 아닌 list_1의 메모리 주소를 list_2에 할당)
#list_2[0]이 list_1[0]과 같은 자리에 할당됨
# 따라서 list_2[0]가 list_1[0]과 같은 값이 됨
# 얕은 복사 / 가변 데이터의 특징

x = 10 # 1. x 에 10 할당
y = x  # 2. y 에 x(에서 정의된) 10 할당
x = 20 # 3. x 가 20으로 재할당  ㅌㅌ
print(x) # 20
print(y) # 10

```
Type Conversion
    1. 인터프리터가 알아서 변경
    2. 직접 변경

1번 = 암시적 형변환
- Boolean 과 Numeric Type 에서만 가능
```python
print(3 + 5.0) # 8.0
print(True + 3) # 4 (True = 1, False = 0)
print(True + False) # 1  + 0 
#문자 + 문자 = Err
```
2번 = 명시적 형변환
 - 개발자가 직접 변경함.
 - str -> integer : 형식에 맞는 숫자만 가능
 - integer -> str : 모두 가능
 ```python
 print(int('1')) # 1
 print(str(1) + '등') # 1등
 print(float('3.5')) #3.5 
 print(int(3.5)) # 3 

 print(int('3.5')) 
 #ValueError! float 으로 해야겟지?
 dict{'key' : 'value'} # (key 변경 불가)

d = {'a': 1, 'b': 3, 'c':4}  #d를 리스트로 바꾸자 
lst = list(d) #['a', 'b', 'c']
set_d = set(d) # {'a', 'c', 'b'}

lst = [] #비어있음
lst = list() #암튼 비어있음

s = '' #빈 문자열
d = {} #빈 dict
# s = {} 허용 안합니다 위랑 중복;;;
s = set()

y = 10
y -= 4 # (y = y-4) '6' 
 ```

복합연산자
+=  |a = a + b <p>
-=  |<p>
*=  |<p>
/=  |<p>
//= |<p>
%=  |<p>
**= |<p>


#### 비교 연산자 (대소비교 : <,>도 여기임)
==
!=
is
is not
is 비교 연산자

메모리 내에서 같은 객체를 참조하는지 확인
==는 동등성(equality), is 는 식별성(identity)
is는 되도록이면 None, True, False 비교할때 사용
```python
a = [1, 2, 3] #b와 id가 다르다!
b = [1, 2, 3]
print(id(a), id(b))
r1 = a == b
r2 = a is b
print(r1, r2) #True, False(id 다름)
c = a
print(id(a), id(c)) #a 와 c의 id가 같음. 
print(a==c, a is c) #저장된 위치? 같음 아마도.
```
#### 논리 연산자
    and | 논리곱
    or  | 논리합
    not | 논리부정
비교 연산자와 함께 사용 가능 

- 단축평가<p>
    and
    - 첫 피연산자 False = 전체 False (두번째 무시)
    - 첫 피연산자 True = 두 번째에 결정 (두번째 결과가 전체 표현식의 결과)
  
    or (p.113)
  
```python
#숫자 0은 False 이외 True
print(3 and 5) # 5
print(3 and 0) # 0 
a = 3
if a:
    print('T')
print(0 or 3)

vocales ='aeiou'
print(('a' and 'b') in vocales) #False 
# a and >> True >> and b (True x True) > b > b in vocales > False.
print(('b' and 'a') in vocales) # True
if 'a': #문자열은 True인건가 // 빈 문자열은 False
    print('T') 
```
#### 멤버쉽 연산자

in <p> 왼쪽 피연산자가 오른쪽 피연산자 시퀀스에 속하는가 <p>
not in <P>왼쪽이 오른쪽에 없는지
```python
chars = 'apple'
s = 'aeiou'
for c in chars:
    if c not in s:
        print(c) #자음만 출력된다.
```
#### 시퀀스형 연산자
``````
+ 결합
* 반복
``````

### 2023_07_19

### 함수!
    특정 작업을 수행하기 위한 재사용 가능한 코드 묶음
    재사용성 / 가독성 / 유지보수성

#### 내장함수
파이썬이 기본적으로 제공하는 함수
별도의 import 필요 X
```python
#사실 얘도!?
print() #return이 없는 함수.
len()
abs() # abs 함수 호출의 반환 값을 result에 할당함.
return #은 함수의 종료 / 결과를 호출부분에 반환.
---

#함수 호출
function_name(arguments) #암튼 실행함

def make_sum(pram1, pram2):
    #pram - 매개변수 (parameter)
    #인자 - argument 
    """ << docstring (주로 함수 설명)
    이것은 두 수를 받아 두 수의 합을 반환하는 함수임.
    >>> make_sum(1, 2)
    3
    """ 
    return pram1 + pram2
```
[python documentation](https://docs.python.org/ko/3/) 무려 자습서도 있음

```python
# 함수 정의
def greet(name):
    """입력된 이름 값에 
    인사를 하는 메세지를 만드는 함수
    """
    message = 'Hello, ' + name
    return message
# 함수 호출
result = greet('Alice')
print(result)

```
매개변수 - parameter
- 함수를 정의할 때 함수가 받을 값을 나타내는 변수<p>
인자 - argument
- 함수를 호출할 때, 실제로 전달되는 값

```python
def add_numbers(x, y): #x, y 매개변수
    result = x + y
    return result

a = 2
b = 3
sum_result = add_numbers(a, b) #a, b 인자
```
>Positional Arguments (위치인자)
- 함수 호출 시 인자의 위치에 따라 전달되는 인자
-  위치인자는 함수 호출 시 반드시 값을 전달해야 함.

> Default Argument Values.
- 함수 정의에서 매개변수에 기본 값을 할당하는 것
- 함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당.

```python
def greet(name, age = 30):# age가 기본인자. (인자 전달 안하면 기본값이 할당)
    print(f'안녕하세요, {name}님! {age}살이시군요!')
```
> Keyword Arguments( 키워드 인자)

매개변수와 인자를 일치시키지 않고 특정 매개변수에 값을 할당할 수 있음

인자의 순서는 주용하지 않으며, 인자의 이름을 명시하여 전달

  *단 호출 시 키워드 인자는 위치 인자 뒤*
  
```python
  #키워드 인자
def greet(name, age):
    print(f'안녕하세요, {name}님! {age})

greeting('Alice', 25) # 안녕하세요, Alices님! 25
greeting(25, 'Alice') # 안녕하세요, 25님 Alice
greeting(age = 25, name= 'Alice') # 안녕하세요, Alices님! 25
greeting(age=25, 'Dave')
#positional argument follows keyword argument. 문법에러.
```
Arbitrary Argument Lists (임의의 인자 목록)
- 정해지지 않은 개수의 인자를 처리하는 인자
- 함수 정의 시 매개변수 앞에 '*' 붙여 사용
- 여러개의 인자를 **tuple**로 처리
```python
def calculate_sum(*args):
    print(args)
    total = sum(args)
    print(f'합계: {total})
    """
    (1, 2, 3)
    합계: 6
    """


``` 
Arbitrary Keyword Argument Lists(임의의 **키워드 인자** 목록)
- 정해지지 않은 개수의 키워드 인자를 처리하는 인자
- 정의 시 매개변수 앞에 ** 
-  dictionary로 묶어 처리 {A:B}
```python
def print_info(**kwargs):
    print(kwargs)

print_info(name ='Eve', age = 30)
#{'name' : 'Eve', 'age' : 30}
```
함수 인자 **권장** 작성순서
위치 > 기본 > 가변 > 키워드 > 가변 키워드
호출 시 인자를 전달하는 과정에서 혼란 줄임<p>
단, 절대적 규칙은 아님.

```python
print(*objects,sep= ' ',end='\n', file=sys, stdout, flush=False)
 # 프린트문 줄바꿈 하는 이유가 여기 있었네
 # 그래서 \n(기본인자)을 바꾼다면
 print('hello',end= ' ') #\n 대신 ' '공백 
```
Python의 범위
- 함수는 코드 내부에 local scope 생성/
- 그 외의 공간 global scope로 구분
    -scope
        -global scope :코드 어디서든 참조가능
        - local scope : 함수가 만든 scope(함수 내부에서만 참조 가능)
    - variable
        - global variable : global scope에 정의된 변수 
        - local variable : local scope에 정의된 변수
  ej. 변수의 수명주기
```python
  def func():
    num = 20 
    print('local',num) # local 20
func() 
print('global', num) # NameError : name 'num' is not defined.
```
수명주기 (lifecycle)
1. built-in scope
   -파이썬 내장
2. global scope
   - 모듈 호출 시점
3. local scope
   -함수가 호출 될 때 생성 , 함수 종료까지 유지
이름 검색 규칙 (Name Resolution)
파이썬에서 사용되는 이름은 특정한 이름공간(namespace)에 저장되어 있음
아래 순서로 찾아나감 LEGB Rule 이라고 부름
1. local scope (현재 작업범위)
2. Enclosed scope 한단계 위 범위
3. Global scope 최상단
4. Buil-in scope. 모든 것(정의하지 않고 사용 가능한 모든 것)
   함수 내에서는 바깥 Scope의 변수에 접근 가능하나 수정은 불가함. 

LEGB Rule ej.

sum이라는 이름을 global scope에서 사용하게 되면서 기존 built-in scope의 sum 사용 못하게 됨
```python

print(sum) # <built-in function sum>
print(sum(range(3))) # 3

sum = 5

print(sum) # 5
print(sum(range(3))) # TypeError: 'int' object is not callable

#다른 예시
#### LEGB Rule 예시 2

a = 1
b = 2


def enclosed():
    a = 10
    c = 3

    def local(c):
        print(a, b, c) # 10 2 500

    local(500)
    print(a, b, c) # 10 2 3


enclosed()
print(a, b) # 1 2

```
global 키워드
- 변수 스코프 전역범위로
- 일반적으로 함수 내에서 전역변수를 수정하려는 경우
- 매개변수에 X
- (가급적 사용X 권장 / )
```python
num = 0 # 전역 변수


def increment():
    global num # num를 전역 변수로 선언
    num += 1


print(num) # 0
increment()
print(num) # 1
```
#### 재귀함수!
- 1개 이상의 base case, 수렴하도록 작성
- 무한호출 조심 / 반복 호출이 종료조건을 향하게 <p> 
ej. 팩토리얼(5!)
f(4) = 4 * f(3)
f(3) = 3 * f(2)
f(2) = 2 * f(1)
f(1) = 1
```python
def factorial(n):
    #종료 조건 n이 0이면 1을 반환
    if n == 0:
        return 1
    #재귀 호출 : n과 n-1의 팩토리얼을 곱한 값 반환
    return n * factorial(n-1)

#계산예시
result = factorial(5) # 여기가 최종결과 장소
print(result) # 120
```

유-용 내장 함-수
1. map
2. zip(*literable) (zip(a,b,c,...,etc))
 : 임의의 iterable을 모아 튜플을 원소로 하는 zip object 반환
```python
map(funcion, iterable) #iterable : 반복가능 객체
#그리고 맵 오브젝트로 반환



```
lambda 함수 - 익명함수
```python

lambda 매개변수 : 표현식(,범위)

def addition(x,y):
    return x + y

result = addition(3, 5)
print(result) #8

addition = lambda x, y : x + y
result = addition(3, 5)
# (설명용 예시)

```

> Packing & Unpacking

- Packing 
  <p>여러개의 값을 하나의 변수에 묶어 담는 것

  괄호 디졋 
```python
packed_values = 1, 2, 3, 4, 5
print(*packed_values)  # 1, 2, 3, 4, 5
print(packed_values)  # (1, 2, 3, 4, 5)

numbers = [1, 2, 3, 4, 5]
a, *b, c = numbers

print(a) # 1
print(b) # [2, 3, 4]
print(c) # 5
# a 1개 c 1개 b 나머지 (3개)
```
- Unpacking 
  <p> 패킹된 변수의 값을 개별적인 변수로 분리하여 할당하는 것
```python
packed_values = 1, 2, 3, 4, 5
a, b, c, d, e = packed_values #알아서 잘라버린듯
print(a, b, c, d, e)  # 1 2 3 4 5

def my_function(x, y, z):
    print(x, y, z)

my_dict = {'x': 1, 'y': 2, 'z': 3}
my_function(**my_dict)  # 1 2 3 #
    # * 리스트 튜플
    # ** 딕셔너리 키 값 쌓
```
### 모듈 Module
Aㅏ...<p>
한 파일로 묶인 변수와 함수의 모음<p>
특정한 기능을 하는 코드가 작성된 파이썬 파일(.py)

ej.
```python
import math
print(math.pi)  # 3.141592653589793    
print(math.sqrt(4))  # 2.0
```
[math module 참고](https://docs.python.org/3/library/math.html)
<p> or 

```python

help(math) #<- 모듈에 뭐 있는지 확인
"""
. (dot)’은
 “점의 왼쪽 객체에서 점의 오른쪽 이름을 찾아라“ 라는 의미의 연산자
"""
# 모듈명.변수명
print(math.pi) #math의 pi 쓸것

# 모듈명.함수명
print(math.sqrt(4))

"""
모듈을 import하는 다른 방법
from 절을 활용해 특정 모듈을 미리 참조하고 어떤 요소를 import 할지 명시
"""
from math import pi, sqrt


print(pi)

print(sqrt(4))

# 마지막에 import된 이름으로 대체됨

from math import pi, sqrt
from my_math import sqrt

# 그래서 모듈 내 모든 요소를 한번에 import 하는 * 표기는 권장하지 않음

from math import * #<- 흐즈믈르그
```
모듈 만들어서 써봤음.

### [파이썬 표준 라이브러리](https://docs.python.org/ko/3/library/index.html)<p>
구경 ㄱ

패키지 : 관련된 모듈들을 하나의 디렉토리에 모은 것
```python
from my_package.math import my_math
# mpcg 패키지의 math 패키지의 my_math 모듈
```
내부 패키지 : 걍 쓰세요<p>
외부 패키지 : pip 사용 후 import 필요<p>
pip 파이썬 패키지 관리자<p>
PyPI에 저장된 외부 패키지들을 설치

패키지 :<p> 모듈의 이름 공간을 구분하여 충돌 방지<p> 모듈들을 효율적으로 관리하고 재사용할 수 있도록 돕는 역할.
\
정의 , 호출은 다른 것 (재귀)

### 2023_07_20

제어문

> 조건문 - Conditional Statement
주어진 조건식 평가 > True 일때만 일함
if / elif / else

```python
if abc:
    블록 1
elif abc:
    블록 1
else: #위 두개가 모두 False일때

    블록 1 
```
> 반복문 Loop Statement<p>
주어진 코드 여러번 반복
1. 특정 작업 반복<p>
2.주어진 조건이 참인동안

for / while

'for' statement
임의의 시퀀스의 항목들을 그 시퀀스에 들어있는 순서대로 반복<p>
기본 구조
```python
for 변수 in iterable:
    블록
    블록
```
iterable - 반복가능한 객체. (시퀀스 객체 + dict + set)
 
<p> for문 원리 
- 리스트 내 첫 항목이 반복 변수에 할당되고 코드블록 실행
-  반복 변수 리스트 2번째 항목 할당, 코드블록 실행
-  ... 마지막으로 반복변수에 리스트 마지막 할당, 코드블록 실행 

```python
items = ['apple', 'banana', 'coconut']
for item in items:
    print(item) # apple // banana // coconut    

문자열 순회
country = 'corea'
for char in country: # c // o // r // e // a
    print(char) #문자열도 시퀀스다.

range 순회
for i in range(5):
    print(i) # 0 // 1 // 2 // 3 // 4

인덱스로 리스트 순회
리스트의 요소가 아닌 인덱스로 접근하여 해당 요소 변경
numbers = [4, 6, 10, -8, 5]
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
print(numbers) # [8, 12, 20, 16, 10]

중첩 for 문
outers = ['A', 'B']
inners = ['c', 'd']

for outer in outers:
    for inner in inners:
        print(outer, inner)
# (A, c) // (A, d) // (B, c) // (B, d)

elements = [['A', 'B'], ['c', 'd']]

중첩 리스트 순회 #2차원 리스트
for elem in elements:
    print(elem)

"""
['A', 'B']
['c', 'd'] 바깥 리스트만 접근가능
"""
elements = [['A', 'B'], ['c', 'd']]

for elem in elements:
    for item in elem:
        print(item)

"""
A       내부 리스트까지 접근함
B
c
d
"""
```

'while' statement
- 주어진 조건식이 참(True)인 동안 코드를 반복해서 실행 == 조건식이 거짓(False)가 될 때 까지 반복


while statement의 기본 구조
```python
while 조!건!식!:
    블록 #if처럼 생겼네요
a = 0 
while a < 3:
    print(a)
    a +=1
print('GG')
# 0 // 1 // 2 // GG
---
number = int(input('양의 정수를 입력해주세요.: '))

while number <= 0:
    if number < 0:
        print('음수를 입력했습니다.')
    else:
        print('0은 양의 정수가 아닙니다.')

    number = int(input('양의 정수를 입력해주세요.: '))

print('잘했습니다!')
"""
양의 정수를 입력해주세요.: 0
0은 양의 정수가 아닙니다.  
양의 정수를 입력해주세요.: -1
음수를 입력했습니다.       
양의 정수를 입력해주세요.: 1
잘했습니다!
"""
```
**while은 반드시 종료조건**<p>

for / while<p>
파이썬 반복문에 사용되는 키워드
for<p>
iterable의 요소를 하나씩 순회하며 반복
while<p>
주어진 조건식이 참인 동안 반복
적절한 반복문 활용하기


for<p>

    반복 횟수가 명확하게 정해져 있는 경우에 유용예를 들어 리스트, 튜플, 문자열 등과 같은 시퀀스 형식의 데이터를 처리할 때
        
 while<p>

    반복 횟수가 불명확하거나 조건에 따라 반복을 종료해야 할 때 유용
    예를 들어 사용자의 입력을 받아서 특정 조건이 충족될 때까지 반복하는 경우

반복제어! 
break - 반복 즉시 중지
continue - 다음 반복으로 건너뜀

남용 X

주의 : 명확하게 작성하도록 노력하시오 
```python 
number = int(input('양의 정수를 입력해주세요.: '))

while number <= 0:
    """
    종료 조건과 break
    """
    if number == -9999: 
        print('프로그램을 종료합니다.') #while adios
        break

    if number < 0:
        print('음수를 입력했습니다.')
    else:
        print('0은 양의 정수가 아닙니다.')

    number = int(input('양의 정수를 입력해주세요.: '))

print('잘했습니다!')

"""
양의 정수를 입력해주세요.: -9999
프로그램을 종료합니다.
잘했습니다!
"""
```
 -아직도 반복문임-
 List Comprehension (효율적 리스트 생성법)
 ```python
 [expression for 변수 in iterable]
list(expression for 변수 in iterable)

# List Comprehension
사용 전

numbers = [1, 2, 3, 4, 5]
squared_numbers = []

for num in numbers:
    squared_numbers.append(num**2)

print(squared_numbers)  # [1, 4, 9, 16, 25]
사용 후

numbers = [1, 2, 3, 4, 5]
squared_numbers = [num**2 for num in numbers]

print(squared_numbers)  # [1, 4, 9, 16, 25]
# 가독성 vs 간결

new_list_3 = [i if i % 2 == 1 else str(i) for i in range(10)]
# 홀수 정수, 짝수 문자열, elif 안됨 if if if if if if if if  됨 

new_list3 = []
for i in range(0,10):
    if i % 2 == 1:
        new_list.append(i) #i를 range만큼 넣음.
    else: 
        new_list.append(str(i)) #위 new list3랑 같지만 가독성 더 좋음
---

# 리스트 만들기 3가지 방법의 비교 
# ej : 정수 1, 2, 3을 가지는 새로운 리스트 만들기
# 상황별로 걍 편하게 쓰세요
# 속도만 따지면 '대부분'의 상황에서는 compre가 빠르다.
# 하지만 다른 함수, 내장함수에 따라 map이 더 빠른 경우도 많았다.
# Python 3.X (후반에) for loop 성능에 비약적 향상이 있었다.
# 극단적 차이는 X.
# 가독성이 매우 중요하다.

numbers = ['1', '2', '3']
# 1. for loop
new_numbers = []
for number in numbers:
    new_numbers.append(int(number))
print(new_numbers)

#2. map
new_nmbers_2 = list(map(int, numbers))
print(new_numbers_2)

# 3. list comprehension
new_numbers_3 = [int(number) for number in numbers]
print(new_numbers_3)

"Simple is better than complex"
"keep it simple, stupid"
 ```
pass - 아무것도 안함. 진짜로 아무것도 안함 
1. 미완성부분 -추후 구현, (컴파일중 오류 피하기)
2. 조건문 패스
3. 무한루프에서 조건이 충족되지 않을 때 pass

Enumerate.
enumerate
```python
fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits):
    print(f'인덱스 {index} : {fruit}')
```
```python 
# enumerate
fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits):
    print(f'인덱스 {index} : {fruit}')
# 인덱스 0 : apple
# 인덱스 1 : banana
# 인덱스 2 : cherry
# enumerate
result = ['a', 'b', 'c']
print(enumerate(result))  # <enumerate object at 0x0000020114BC4BC0>
print(list(enumerate(result))) # [(0, 'a'), (1, 'b'), (2, 'c')] - tuple

for index, elem in enumerate(result): # tuple 언패킹
    print(index, elem) # 0 a // # 1 b // # 2 c
```
문장 - 실행 가능한 동작을 기술하는 코드 (조건문 반복문 함수정의)
 - expression(평가대상임)으로 만:?든?:다


## 2023_07_21

어제 많이 급했나봅니다. 

#### 관통프로젝트 PJT 1 시작.

url 
요청을 보내는 서버의 주소

requests.get(url)
해당 서버(url)에 데이터를 달라고 요청을 보내는 함수

.json()
내부의 데이터를 JSON (python의 dict와 비슷)형태로 변환해주는 함수

API 
클라이언트가 원하는 기능을 수행하기 위해 서버측에 만들어 놓은 프로그램.
 - 기능 예시 : 데이터 저장 조회 수정 삭제
서버 측에 특정 주소로 요청이 오면 정해진 기능을 수행하는 Api 를 미리 만들어 둔다.
- 클라이언트는 서버가 미리 만들어 놓은 주소로 요청을 보낸다.