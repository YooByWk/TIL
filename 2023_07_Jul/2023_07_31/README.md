# 2023_07_31

## APS
알고리즘...이라니요... <p>
Algorithm Problem Solving. <p>
Programming Intermediate -이거 해야죠 <p>

## 배열 1, Array 1

### 알고리즘 
- **유한한** 단계를 통해 문제를 해결하기 위한 절차나 방법
- 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함.
-  간단하게 어떤 문제를 해결하기 위한 절차
  
좋은 알고리즘:
- 정확성 
- 작업량
- 메모리 사용량
- 단순성
- 최적성
---
### 시간복잡도 ( Time Complexity)
- 실제 걸리는 시간 측정, 실행되는 명령문의 개수 계산

- 빅 오 표기법 (big-oh notation)
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시한다 
- 계수(Coefficient)는 생략
- O(n)
  
### 배열
- 일정한 자료형 변수를 하나 이름으로 열거, 사용하는 자료구조
- 하나의 선언으로 둘 이상의 변수 선언
- 단순한 다수의 변수 선언 의미가 아니라, 다수 변수로 하기 힘든 작업을 배열로 할 수 있다.

```py
Arr = [0] * 10
Arr[idx] = 20 # idx 원소에 20을 저장하거라
#대충 이런 느낌
```
저희 파이참 쓸 예정임.

## 정렬

할일
```py
max 안쓰고 최대값 찾기 
min의 경우도 최소 찾아보기.
```
### 버블 정렬
```py
def BubbleSort(a, N): # 정렬할 list, n 원소 수
    for i in range(N-1, 0 , -1):
        for j in range(0,i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
#저는 얘를 이해하지 못했어요.

T = int(input())
for tc in range(1, T+1):
    n = int(input())
    lista = list(map(int, input().split()))

    for i in range(n-1,0,-1): # i 구간의 마지막 idx. n-1(마지막 자리 인덱스)부터 0까지 , 감소하면서
        for j in range(i): #
    # 추측 1 : 두개의 for가 필요한 이유는 한번만 돌면 b c a d e 가 b a c d e 가 될거임...
        # 그러니까 한번 더 돌립니다. 아닐까요?
            if lista[j] > lista[j+1]: # 오름차순이니까 크기 비교
                lista[j], lista[j+1] = lista[j+1], lista[j] # 크면 이거 해라

    print(f'#{tc}', *lista) #  unpacking

#설명해주심

nums = [55, 7, 78, 12, 42]

idx(N-1)<4> : phase # 인덱스 목표 >> [. . . ., 78]
idx (0, 1) 비교 : [55, 7, 78, 12, 42] >  [7, 55, 78, 12, 42] 
idx (1, 2) 비교 : [7, 55, 78, 12, 42] >  [7, 55, 78, 12, 42] 
idx (2, 3) 비교 : [7, 55, 78, 12, 42] >  [7, 55, 12, 78, 42]  
idx (3, 4) 비교 : [7, 55, 12, 78, 42] >  [7, 55, 12, 42, 78]
#여기까지가 for 처음.
for j in range(0, 4): # 이게 phase 1
    if nums[j] > nums[j+1]: # 만약 왼쪽 수가 더 크다면
        nums[j], numsp[j+1] = num[j+1], num[j] # 오른쪽이랑 자리를 바꿉니다.
#다음과정 
n-1 : phase > [...., 55, 78] # 이런 모습을 만들어야함
idx (0, 1) 비교 : [7, 55, 12, 42, 78] >  [7, 55, ...]
idx (1, 2) 비교 : [7, 55, 12, ...]> [7, 12, 55, ...]  
idx (2, 3) 비교 :    
idx (3, 4) 비교 : 
# 이런 과정이다.
따라서
n-1(4)
n-2(3)
n-3(2)
n-4(1) 의 phase로 진행될거임.

def bubble_sort(nums):
    n = len(nums) # 리스트 수
    for phase in range(n-1, 0, -1): 
        #1까지 가야하니까 0으로 적는다 (1개씩 빼면서  가니까)
        for j in range(0, phase): # 
            if nums[j] > nums[j+1]: # 만약 왼쪽 수가 더 크다면
                nums[j], numsp[j+1] = num[j+1], num[j] 
                # 오른쪽이랑 자리를 바꿉니다.

print(nums) # 어차피 list는 ref 타입...

```

### 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형시간(?)에 정렬하는 효율적인 알고리즘

### 선택 정렬

### 퀵 정렬

### 병합 정렬





[이전](../2023_07_30/README.md)

[다음](../../2023_08_AGO/2023_08_01/README.md)
