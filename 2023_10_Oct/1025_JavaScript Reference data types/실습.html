<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    

    const number2 = [1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    const t = number2.reduce((value, number) => {
      return value + number
    }, 10) // 10은 value 의 초기값
    console.log(t) // 하나씩 줄어들면서? // 55 


    const numbers = [1, 2, 3, 4, 5]
    // foreach, map, [filter, find, some, every : boolean 요구] - array  help methods
    // 한 개에 대해서만 함수를 만든다. 순환은 알아서 js가 해준다.


    // forEach

    // const sub = function () {

    // }
    // numbers.forEach(sub()) // 이거 아니다. help mehtod에서 쓰는건 직접 호출 하면 안됨 
    // numbers.forEach(sub) 이렇게 쓰도록

    // numbers.forEach() // 호출

    
    numbers.forEach((number) => {
      console.log(number)
    }) // 호출 - 선언 
    // forEach는  return이 없다. | 넣어도 의미 없다.  "동작용"

    // map
    // 변수도 받아야 함. 반환이 있기 때문
    const res = numbers.map((number)=>{
      return number*2
    })
    console.log(res)
    console.log(typeof(res)) //object

    // filter 포함 자료 True, 미포함 자료 false // return 존재
    const res2 = numbers.filter((number) => {
      if (number%2 === 0) {
        return true // 
      } else {
        return false
      }
    })
    console.log(res2)

    // find : 찾는 데이터 중 첫 번째로 만나는 것을 return
    const res3 = numbers.find((number) => {
      if (number === 2) {
        return true
      }
    } )
    console.log(res3)


    // some : 하나라도 true가 있다면, return true ; else return false
    const res4 = numbers.some((number) => {
      if (number === 2 ) {
        return true
      }
    })


    console.log(res4)
    // every : 모두 true 라면, return true ; else return false
    const res5 = numbers.every((number) => {
      return number<5
    })
    console.log(res5)

    const people = [
      { name : 'A', age : 20 },
      { name : 'B', age : 25 },
      { name : 'C', age : 30 },
      { name : 'D', age : 20 },
    ]

    const res6 = people.filter((person) => {
      if (person.age === 20) {
        return true
      }
    })
    console.log(res6)
    res6.forEach((i) => {
      console.log(i)
    })

    
    const res7 = people.map((persona) => {
      const newP = persona
      newP.city = '광주'
      return newP
    })
    console.log(res7)
    // 얕은 복사라서 res7의 값을 수정해도 people도 바뀐다.
    // 이를 방지해보자

    const res8 = people.map((persona) => {
      const {name, age} = persona
      return {
        name : name,
        age : age,
        city : '광주'
      }
    })
     // 위처럼 똑같은 경우에는. . . 
     const res9 = people.map((persona) => {
      const {name, age} = persona
      return {
      name,
      age,
      city : '광주',
      }
    }) // 아직도 얕은 복사이긴 한데...


    // 전개 '...'
    // 결국 const newP를 만드는 것.
    // 
    const res10 = people.map((persona) => {
      // const {name, age} = persona
      return {...persona, city : '광주'} 
    })
    console.log(res10)
  

    people.forEach((p, idx,c) => {
      return console.log(p,idx,c)
    })
    //{name: 'A', age: 20, city: '광주'} 0 (4) [{…}, {…}, {…}, {…}]
    
  </script>
</body>
</html>